<html><head><title>about_powercli_objects - PowerCLI System.Collections.Hashtable.ModuleName Help Reference</title><meta name="description" content=" about_powercli_objects" /><meta name="keywords" content="PowerCLI System.Collections.Hashtable.ModuleName Help Reference, about_powercli_objects" /><link href="doc-style.css" type="text/css" rel="StyleSheet"></head><body><h1>about_powercli_objects</h1><p class="table-title">Topic</p>VMware PowerCLI Objects<br/><br/><p class="table-title">Short Description</p>Describes some importatant characteristics of the VMware PowerCLI objects.<br/><br/><p class="table-title">Long Description</p>For their input and output, the VMware PowerCLI cmdlets use a set of .NET types that reside in the VMware.VimAutomation.ViCore.Types namespace. For example, the VMware.VimAutomation.ViCore.Types.V1.Inventory.VirtualMachine type describes virtual machine objects. <br/><br/>Each PowerCLI object represents a snapshot of the initial state of a server-side object by the time the PowerCLI object is created. Note that when the server-side object state changes, the state of the PowerCLI object is not automatically updated. To obtain the latest version, you have to retrieve the PowerCLI object from the server again. <br/><br/>This behavior of the PowerCLI objects has some implications illustrated by the following example scenarios.<br/><br/>Scenario 1:<br/><br/>	1. User A obtains an OSCustomizationSpec object ( and stores it in a PowerShell variable).<br/>	2. User B runs the Set-OSCustomizationSpec cmdlet to change the Administrator&#39;s Password in the OS customization specification.<br/>	3. User A runs the Set-VM cmdlet providing the OSCustomizationSpec object obtained in step 1 as a parameter input.<br/><br/>	In result, User A unsuccessfully tries to perform the virtual machine OS customization, without knowing that the AdminPassword property of the OSCustomizationSpec server-side object has been changed by User B.<br/><br/>Scenario 2:<br/><br/>	1. User A obtains a VirtualMachine object (and stores it in a PowerShell variable). The virtual machine is powered off.<br/>	2. User B powers the virtual machine on.<br/>	3. The PowerState property of the VirtualMachine object stored by User A is not updated and its value is PowerdOff. User A tries to power on the virtual machine using the Start-VM cmdlet.<br/><br/>	In result, Start-VM reports an error because the virtual machine is already powered on by User B. <br/><br/>Another important case is working with Task objects. The Get-Task cmdlet returns a Task object and the state of this object is a snapshot of the initial server-side task state. Once you save the retrieved Task object in a PowerShell variable, its State property is never updated with the current state of the task on the server. To check if the server-side task has changed its state, run the Wait-Task cmdlet using the Task object variable as a parameter.<br/><br/>In all cases, when you run a cmdlet it always retrieves and uses the latest version of the object properties for the specified parameters.<br/><br/><br/>Properties Loaded On-Demand<br/>Some of the properties of the PowerCLI objects return other PowerCLI objects. Usually, when you first call such a property, it returns the output object and caches it for a faster return. Thus, every subsequent call to this property returns the cached object. However, every time when you retrieve an object through a cmdlet, the cached values of its properties are erased and the on-demand retrieving of the properties begins again.<br/><br/>Circular References<br/><br/>To address new properties of objects returned by PowerCLI cmdlets, PowerCLI introduces circular references.<br/>For example, the VirtualMachine object has a property named VMResourceConfiguration that is of type VMResourceConfiguration. The VMResourceConfiguration type has a property named VM that is of type VirtualMachine. <br/>In this case, the following expression is true: <br/><br/>	$vm.VMResourceConfiguration.VM.Uid -eq $vm.Uid<br/><br/>The circular references should be taken into account when you use the Format-Custom cmdlet.  By default, the Format-Custom cmdlet makes a full traversal of an object and its references, and this might cause an infinite loop (for example, Get-VM | Format-Custom).<br/><br/><br/>Send feedback to docfeedback@vmware.com | Copyright (C) VMware, Inc. All rights reserved. Protected by one or more U.S. Patents listed at http://www.vmware.com/go/patents.<hr>Copyright &copy; VMware, Inc.&nbsp;All rights reserved.</body></html>
