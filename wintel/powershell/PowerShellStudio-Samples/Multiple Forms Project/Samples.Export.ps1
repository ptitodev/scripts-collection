#------------------------------------------------------------------------
# Source File Information (DO NOT MODIFY)
# Source ID: ae130934-c451-4b12-82dc-56ffd72f6fe3
# Source File: ..\Samples.psproj
#------------------------------------------------------------------------
<#
    .NOTES
    --------------------------------------------------------------------------------
     Code generated by:  SAPIEN Technologies, Inc., PowerShell Studio 2014 v4.1.62
     Generated on:       6/18/2014 3:52 PM
     Generated by:       David
     Organization:       SAPIEN Technologies, Inc.
    --------------------------------------------------------------------------------
    .DESCRIPTION
        Script generated by PowerShell Studio 2014
#>


#region Source: Startup.pss
#----------------------------------------------
#region Import Assemblies
#----------------------------------------------
[void][Reflection.Assembly]::Load('mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
[void][Reflection.Assembly]::Load('System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
[void][Reflection.Assembly]::Load('System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
[void][Reflection.Assembly]::Load('System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
[void][Reflection.Assembly]::Load('System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
[void][Reflection.Assembly]::Load('System.Xml, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
[void][Reflection.Assembly]::Load('System.DirectoryServices, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
[void][Reflection.Assembly]::Load('System.Core, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
[void][Reflection.Assembly]::Load('System.ServiceProcess, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
#endregion Import Assemblies



function Main {
	Param ([String]$Commandline)
	#Note: This function starts the application
	#$Commandline contains the complete argument string passed to the packager
	#TODO: Initialize and add Function calls to forms

	Write-Host $Commandline

	if(Call-MainForm_psf -eq "OK")
	{
	
	}
	
	$script:ExitCode = 0 #Set the exit code for the Packager
}




#endregion Source: Startup.pss

#region Source: MainForm.psf
function Call-MainForm_psf
{
	#----------------------------------------------
	#region Import the Assemblies
	#----------------------------------------------
	[void][reflection.assembly]::Load('mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
	[void][reflection.assembly]::Load('System.Xml, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System.DirectoryServices, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
	[void][reflection.assembly]::Load('System.Core, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System.ServiceProcess, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
	#endregion Import Assemblies

	#----------------------------------------------
	#region Generated Form Objects
	#----------------------------------------------
	[System.Windows.Forms.Application]::EnableVisualStyles()
	$form1 = New-Object 'System.Windows.Forms.Form'
	$buttonTopProcesses = New-Object 'System.Windows.Forms.Button'
	$buttonSystemInfo = New-Object 'System.Windows.Forms.Button'
	$buttonComputerPrompt = New-Object 'System.Windows.Forms.Button'
	$buttonADUserForm = New-Object 'System.Windows.Forms.Button'
	$InitialFormWindowState = New-Object 'System.Windows.Forms.FormWindowState'
	#endregion Generated Form Objects

	#----------------------------------------------
	# User Generated Script
	#----------------------------------------------
	
	function OnApplicationLoad {
		#Note: This function runs before the form is created
		#Note: To get the script directory in the Packager use: Split-Path $hostinvocation.MyCommand.path
		#Note: To get the console output in the Packager (Windows Mode) use: $ConsoleOutput (Type: System.Collections.ArrayList)
		#Important: Form controls cannot be accessed in this function
		#TODO: Add snapins and custom code to validate the application load
		
		return $true #return true for success or false for failure
	}
	
	function OnApplicationExit {
		#Note: This function runs after the form is closed
		#TODO: Add custom code to clean up and unload snapins when the application exits
		
		$script:ExitCode = 0 #Set the exit code for the Packager
	}
	
	$FormEvent_Load={
		#TODO: Initialize Form Controls here
		
	}
	
	$buttonADUserForm_Click={
		#TODO: Place custom script here
		Call-ADUserForm_psf
	}
	
	$buttonComputerPrompt_Click={
		#TODO: Place custom script here
		Call-ComputerPrompt_psf
	}
	
	$buttonSystemInfo_Click={
		#TODO: Place custom script here
		Call-SystemInformation_psf
	}
	$script:
	$buttonTopProcesses_Click={
		#TODO: Place custom script here
		Call-TopProcesses_psf
	}
	
	
	
	
	
		# --End User Generated Script--
	#----------------------------------------------
	#region Generated Events
	#----------------------------------------------
	
	$Form_StateCorrection_Load=
	{
		#Correct the initial state of the form to prevent the .Net maximized form issue
		$form1.WindowState = $InitialFormWindowState
	}
	
	$Form_StoreValues_Closing=
	{
		#Store the control values
	}

	
	$Form_Cleanup_FormClosed=
	{
		#Remove all event handlers from the controls
		try
		{
			$buttonTopProcesses.remove_Click($buttonTopProcesses_Click)
			$buttonSystemInfo.remove_Click($buttonSystemInfo_Click)
			$buttonComputerPrompt.remove_Click($buttonComputerPrompt_Click)
			$buttonADUserForm.remove_Click($buttonADUserForm_Click)
			$form1.remove_Load($FormEvent_Load)
			$form1.remove_Load($Form_StateCorrection_Load)
			$form1.remove_Closing($Form_StoreValues_Closing)
			$form1.remove_FormClosed($Form_Cleanup_FormClosed)
		}
		catch [Exception]
		{ }
	}
	#endregion Generated Events

	#----------------------------------------------
	#region Generated Form Code
	#----------------------------------------------
	$form1.SuspendLayout()
	#
	# form1
	#
	$form1.Controls.Add($buttonTopProcesses)
	$form1.Controls.Add($buttonSystemInfo)
	$form1.Controls.Add($buttonComputerPrompt)
	$form1.Controls.Add($buttonADUserForm)
	$form1.ClientSize = '149, 141'
	$form1.FormBorderStyle = 'FixedDialog'
	$form1.MaximizeBox = $False
	$form1.MinimizeBox = $False
	$form1.Name = "form1"
	$form1.Text = "Samples"
	$form1.add_Load($FormEvent_Load)
	#
	# buttonTopProcesses
	#
	$buttonTopProcesses.Location = '12, 99'
	$buttonTopProcesses.Name = "buttonTopProcesses"
	$buttonTopProcesses.Size = '125, 23'
	$buttonTopProcesses.TabIndex = 3
	$buttonTopProcesses.Text = "Top Processes"
	$buttonTopProcesses.UseVisualStyleBackColor = $True
	$buttonTopProcesses.add_Click($buttonTopProcesses_Click)
	#
	# buttonSystemInfo
	#
	$buttonSystemInfo.Location = '12, 70'
	$buttonSystemInfo.Name = "buttonSystemInfo"
	$buttonSystemInfo.Size = '125, 23'
	$buttonSystemInfo.TabIndex = 2
	$buttonSystemInfo.Text = "System Information"
	$buttonSystemInfo.UseVisualStyleBackColor = $True
	$buttonSystemInfo.add_Click($buttonSystemInfo_Click)
	#
	# buttonComputerPrompt
	#
	$buttonComputerPrompt.Location = '12, 41'
	$buttonComputerPrompt.Name = "buttonComputerPrompt"
	$buttonComputerPrompt.Size = '125, 23'
	$buttonComputerPrompt.TabIndex = 1
	$buttonComputerPrompt.Text = "Computer Prompt"
	$buttonComputerPrompt.UseVisualStyleBackColor = $True
	$buttonComputerPrompt.add_Click($buttonComputerPrompt_Click)
	#
	# buttonADUserForm
	#
	$buttonADUserForm.Location = '12, 12'
	$buttonADUserForm.Name = "buttonADUserForm"
	$buttonADUserForm.Size = '125, 23'
	$buttonADUserForm.TabIndex = 0
	$buttonADUserForm.Text = "AD User Form"
	$buttonADUserForm.UseVisualStyleBackColor = $True
	$buttonADUserForm.add_Click($buttonADUserForm_Click)
	$form1.ResumeLayout()
	#endregion Generated Form Code

	#----------------------------------------------

	#Save the initial state of the form
	$InitialFormWindowState = $form1.WindowState
	#Init the OnLoad event to correct the initial state of the form
	$form1.add_Load($Form_StateCorrection_Load)
	#Clean up the control events
	$form1.add_FormClosed($Form_Cleanup_FormClosed)
	#Store the control values when form is closing
	$form1.add_Closing($Form_StoreValues_Closing)
	#Show the Form
	return $form1.ShowDialog()
}
#endregion Source: MainForm.psf

#region Source: ADUserForm.psf
function Call-ADUserForm_psf
{
	#----------------------------------------------
	#region Import the Assemblies
	#----------------------------------------------
	[void][reflection.assembly]::Load('mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
	[void][reflection.assembly]::Load('System.Xml, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System.DirectoryServices, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
	[void][reflection.assembly]::Load('System.Core, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System.ServiceProcess, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
	#endregion Import Assemblies

	#----------------------------------------------
	#region Generated Form Objects
	#----------------------------------------------
	[System.Windows.Forms.Application]::EnableVisualStyles()
	$form1 = New-Object 'System.Windows.Forms.Form'
	$label2 = New-Object 'System.Windows.Forms.Label'
	$radioDisabled = New-Object 'System.Windows.Forms.RadioButton'
	$radioEnabled = New-Object 'System.Windows.Forms.RadioButton'
	$rtbAccountInfo = New-Object 'System.Windows.Forms.RichTextBox'
	$btnQuit = New-Object 'System.Windows.Forms.Button'
	$listUsers = New-Object 'System.Windows.Forms.ListBox'
	$chkForceChange = New-Object 'System.Windows.Forms.CheckBox'
	$lblNewPassword = New-Object 'System.Windows.Forms.Label'
	$txtPassword = New-Object 'System.Windows.Forms.TextBox'
	$btnReset = New-Object 'System.Windows.Forms.Button'
	$progressBar1 = New-Object 'System.Windows.Forms.ProgressBar'
	$statusBar1 = New-Object 'System.Windows.Forms.StatusBar'
	$label1 = New-Object 'System.Windows.Forms.Label'
	$InitialFormWindowState = New-Object 'System.Windows.Forms.FormWindowState'
	#endregion Generated Form Objects

	#----------------------------------------------
	# User Generated Script
	#----------------------------------------------
	Function Get-IsEnabled {
	    Param([string]$username=$(Throw "You must specify a user's CN"))
	    
	#    This function will look at the useraccountcontrol flag and
	#   and return $True if the account is enabled
	          
	   New-Variable ADS_UF_ACCOUNTDISABLE 2 -Option constant
	        
	   #define our searcher object
	    $Searcher = New-Object DirectoryServices.DirectorySearcher
	    
	    # find the account
	    $filter="(&(objectCategory=person)(objectClass=user)(cn=$username))"
	    $searcher.filter=$filter
	    
	    #get the user account
	    $result=$searcher.findOne() 
	    [ADSI]$user=$result.path
	    $flag=$user.userAccountcontrol.value 
	    
	    if ($flag) {
	        if ($flag -band $ADS_UF_ACCOUNTDISABLE) {
	#           Write-Host "account is disabled "
	          write $False
	         }
	         else {
	#           Write-Host "account is enabled"
	          write $True
	         }
	    }
	 else {
	    Write-Warning "Failed to find $username"
	 }
	
	}
	
	Function EnableDisable-UserAccount {
	    Param([string]$username=$(Throw "You must specify a user's CN"))
	    
	#    This function will look at the useraccountcontrol flag and
	#    determine if the account is enabled or disabled. It will 
	#    flip the bits to enable a disabled account or disable an enabled 
	#    account.
	          
	   New-Variable ADS_UF_ACCOUNTDISABLE 2 -Option constant
	        
	   #define our searcher object
	    $Searcher = New-Object DirectoryServices.DirectorySearcher
	    
	    # find the account
	    $filter="(&(objectCategory=person)(objectClass=user)(cn=$username))"
	    $searcher.filter=$filter
	    
	    #get the user account
	    $result=$searcher.findOne() 
	    [ADSI]$user=$result.path
	    $flag=$user.userAccountcontrol.value 
	    
	    if ($flag) {
	        if ($flag -band $ADS_UF_ACCOUNTDISABLE) {
	#           Write-Host "account is disabled and enabling"
	          $user.useraccountcontrol=$flag -bxor $ADS_UF_ACCOUNTDISABLE
	         }
	         else {
	#           Write-Host "account is enabled and disabling"
	          $user.useraccountcontrol=$flag -bor $ADS_UF_ACCOUNTDISABLE
	         }
	          $user.SetInfo()
	    }
	 else {
	    Write-Warning "Failed to find $username"
	 }
	
	}
	
	
	Function Change-Userpassword {
	    Param([string]$username=$(Throw "You must specify a user's CN"),
	          [string]$password="P@ssw0rd",
	          [switch]$forceChange
	          )
	          
	   #define our searcher object
	    $Searcher = New-Object DirectoryServices.DirectorySearcher
	    
	    # find the account
	    $filter="(&(objectCategory=person)(objectClass=user)(cn=$username))"
	    $searcher.filter=$filter
	    
	    #get the user account
	    $result=$searcher.findOne() 
	    [ADSI]$user=$result.path
	    
	    #change the password
	    $user.SetPassword($password)
	    
	    #if -forcechange then modify user account to force user to change 
	    #password at next logon
	    if ($forceChange) 
	    {
	        $user.Put("pwdLastSet",0) 
	        $user.SetInfo()
	     } 
	
	}
	
	Function Get-UserAccount {
	    Param ([string]$username="Administrator")  
	    #define some functions used in the script
	    #get the age of the password in days
	    #a value of 0 means just set or needs to be set
	    #the value of $LastSet will be a large integer
	    #indicating the number seconds since 1/1/1601
	    #since the password was set
	    
	    Function Get-UTCAge {
	        #get date time of the last password change
	            Param([int64]$Last=0)
	            if ($Last -eq 0) {
	                write 0
	            } else {
	                #clock starts counting from 1/1/1601.
	                [datetime]$utc="1/1/1601"
	                #calculate the number of days based on the int64 number
	                $i=$Last/864000000000
	                
	                #Add the number of days to 1/1/1601
	                #and write the result to the pipeline
	                write ($utc.AddDays($i))
	            }
	        } # end Get-UTCAge function
	    
	    Function Get-PwdAge {
	    
	      Param([int64]$LastSet=0) 
	      
	      
	        if ($LastSet -eq 0) {
	            write "0"
	        } else {
	            #get the date the password was last changed
	            [datetime]$ChangeDate=Get-UTCAge $LastSet
	            
	            #get the current date and time
	            [datetime]$RightNow=Get-Date
	            
	            #write the difference in days
	            write $RightNow.Subtract($ChangeDate).Days
	        }
	    } #end Get-PwdAge function
	        
	         
	    #main code
	    #define some constants
	    
	    New-Variable ADS_UF_ACCOUNTDISABLE 0x0002 -Option Constant
	    New-Variable ADS_UF_PASSWD_CANT_CHANGE 0x0040 -Option Constant
	    New-Variable ADS_UF_DONT_EXPIRE_PASSWD 0x10000 -Option Constant
	    New-Variable ADS_UF_PASSWD_EXPIRED 0x800000 -Option Constant
	    
	    #define our searcher object
	    $Searcher = New-Object DirectoryServices.DirectorySearcher
	    
	    # find the account
	    $filter="(&(objectCategory=person)(objectClass=user)(cn=$username))"
	    $searcher.filter=$filter
	    
	    #get the user account
	    $searcher.findOne() | ForEach-Object {
	    
	    #get password properties from useraccountcontrol field
	        if ($_.properties.item("useraccountcontrol")[0] -band $ADS_UF_DONT_EXPIRE_PASSWD) {
	            $pwdNeverExpires=$True
	         }
	         else {
	            $pwdNeverExpires=$False
	         }
	         
	         #Password expired should be calculated from a computed UAC value
	         $user=$_.GetDirectoryEntry()
	         $user.psbase.refreshcache("msDS-User-Account-Control-Computed")
	         [int]$computed=$user.psbase.properties.item("msDS-User-Account-Control-Computed").value
	            
	         if ($computed -band $ADS_UF_PASSWD_EXPIRED) {
	            $pwdExpired=$True
	         }
	         else {
	            $pwdExpired=$False
	         }
	         
	         #check if user can change their password
	         if ($_.properties.item("useraccountcontrol")[0] -band $ADS_UF_PASSWD_CANT_CHANGE) {
	            $pwdChangeAllowed=$False
	         }
	         else {
	            $pwdChangeAllowed=$True
	         }
	        #create a custom object for the account and password properties
	        $obj=New-Object PSObject
	        
	        #add properties to the object
	        $obj | Add-Member -MemberType NoteProperty -Name "Name" -Value $_.properties.item("name")[0]
	        $obj | Add-Member -MemberType NoteProperty -Name "DN" -Value $_.properties.item("distinguishedname")[0]
	        $obj | Add-Member -MemberType NoteProperty -Name "Description" -Value $_.properties.item("description")[0]
	        $obj | Add-Member -MemberType NoteProperty -Name "AccountCreated" -Value $_.properties.item("whencreated")[0]
	        $obj | Add-Member -MemberType NoteProperty -Name "AccountModified" -Value $_.properties.item("WhenChanged")[0]
	        $obj | Add-Member -MemberType NoteProperty -Name "LastLogon" -Value (Get-UTCAge $_.properties.item("lastlogon")[0])
	        $obj | Add-Member -MemberType NoteProperty -Name "PasswordLastChanged" -Value (Get-UTCAge $_.properties.item("pwdlastset")[0])
	        $obj | Add-Member -MemberType NoteProperty -Name "PasswordAge" -Value (Get-PwdAge $_.properties.item("pwdlastset")[0])
	        $obj | Add-Member -MemberType NoteProperty -Name "PasswordExpired" -Value $pwdExpired
	        $obj | Add-Member -MemberType NoteProperty -Name "PasswordNeverExpires" -Value $pwdNeverExpires
	        $obj | Add-Member -MemberType NoteProperty -Name "PasswordChangeAllowed" -Value $pwdChangeAllowed
	        
	        #write object to the pipeline
	        write $obj
	        
	     } #end foreach
	}
	
	
	
	function OnApplicationLoad {
	#TODO: Add custom code to validate application load
	#TODO: Add Snapins here
	
		return $true #return true for success or false for failure
	}
	
	function OnApplicationExit {
	#TODO: Add custom code clean up on application exit
	
	}
	
	$GetUser={
	  $statusBar1.text="Getting account information for {0}" -f $listUsers.SelectedItem
	    $user=Get-UserAccount $listUsers.SelectedItem | Out-String
	    $rtbAccountInfo.Text=$user.Trim() 
	    
	    #get enable/disable information
	    if (Get-IsEnabled $listUsers.SelectedItem) {
	      $radioEnabled.checked=$True
	    }
	    else {
	      $radioDisabled.Checked=$True
	    }
	    
	    $statusBar1.Text="Ready"
	}
	
	
	$ResetPassword={
	 $password=($txtPassword.Text).Trim()
	    
	    if ($password.length -eq 0) {
	    Write-Warning "Blank passwords are not allowed"
	    Return
	    }
	    
	    $user=$listUsers.Selecteditem
	    $statusBar1.Text="Resetting password for {0}" -f $listUsers.SelectedItem
	    
	    if ($chkForceChange.Checked) {
	      Change-Userpassword -username $user -password $password -forcechange
	    }
	    else {
	      Change-Userpassword -username $user -password $password
	    }
	   #refresh the user account 
	   
	   &$GetUser
	
	   #reset defaults
	   $txtPassword.text=""
	   $chkForceChange.Checked=$True
	}
	
	$Close={
	    $form1.close()
	
	}
	
	$Populate={
	    $statusBar1.text="Getting users"
	    
	    $searcher=New-Object DirectoryServices.DirectorySearcher
	    $searcher.Filter="(&(objectcategory=person)(objectclass=user))"
	    $searcher.pageSize=100
	    $progressBar1.value=2
	    $users=$searcher.FindAll()
	      
	    $i=0
	    if ($users) {
	    $users | foreach {
	      $listUsers.Items.add($_.Properties.cn[0])
	      $i++
	      $progressBar1.value=($i/$users.count) * 100
	    }
	        
	    $statusBar1.text="Ready"
	    $progressBar1.Visible=$False
	    $label1.Visible=$True
	    $listUsers.Visible=$True
	    $lblNewPassword.Visible=$True
	    $chkForceChange.Visible=$True
	    $txtPassword.Visible=$True
	    $btnReset.Visible=$True
	    $btnQuit.Visible=$True
	    $rtbAccountInfo.Visible=$True
	    $radioEnabled.Visible=$True
	    $radioDisabled.Visible=$True
	    #select the first user in the list
	    $listUsers.SelectedIndex=0
	    
	    }
	    else {
	    #close the form if there are errors getting users
	    $form1.close()
	    }
	}
	
	$ShowTip= {
	   $label2.Visible=$True
	}
	
	$HideTip= {
	   $label2.Visible=$False
	}
	
	
	$ChangeAccount={
	    #flip enable/disable status
	    if ($radioEnabled.Checked) {
	        $statusBar1.Text="Disabling {0}" -f $listUsers.SelectedItem
	    }
	    else {
	         $statusBar1.Text="Enabling {0}" -f $listUsers.SelectedItem
	    }
	    
	    EnableDisable-UserAccount $listUsers.SelectedItem
	    
	    #refresh user account information
	    &$GetUser 
	
	}
	
	
	
	
	
		# --End User Generated Script--
	#----------------------------------------------
	#region Generated Events
	#----------------------------------------------
	
	$Form_StateCorrection_Load=
	{
		#Correct the initial state of the form to prevent the .Net maximized form issue
		$form1.WindowState = $InitialFormWindowState
	}
	
	$Form_StoreValues_Closing=
	{
		#Store the control values
		$script:ADUserForm_radioDisabled = $radioDisabled.Checked
		$script:ADUserForm_radioEnabled = $radioEnabled.Checked
		$script:ADUserForm_rtbAccountInfo = $rtbAccountInfo.Text
		$script:ADUserForm_listUsers = $listUsers.SelectedItems
		$script:ADUserForm_chkForceChange = $chkForceChange.Checked
		$script:ADUserForm_txtPassword = $txtPassword.Text
	}

	
	$Form_Cleanup_FormClosed=
	{
		#Remove all event handlers from the controls
		try
		{
			$radioDisabled.remove_Click($ChangeAccount)
			$radioDisabled.remove_MouseEnter($ShowTip)
			$radioDisabled.remove_MouseLeave($HideTip)
			$radioEnabled.remove_Click($ChangeAccount)
			$radioEnabled.remove_MouseEnter($ShowTip)
			$radioEnabled.remove_MouseLeave($HideTip)
			$btnQuit.remove_Click($Close)
			$listUsers.remove_SelectedIndexChanged($GetUser)
			$btnReset.remove_Click($ResetPassword)
			$form1.remove_Shown($Populate)
			$form1.remove_Load($Form_StateCorrection_Load)
			$form1.remove_Closing($Form_StoreValues_Closing)
			$form1.remove_FormClosed($Form_Cleanup_FormClosed)
		}
		catch [Exception]
		{ }
	}
	#endregion Generated Events

	#----------------------------------------------
	#region Generated Form Code
	#----------------------------------------------
	$form1.SuspendLayout()
	#
	# form1
	#
	$form1.Controls.Add($label2)
	$form1.Controls.Add($radioDisabled)
	$form1.Controls.Add($radioEnabled)
	$form1.Controls.Add($rtbAccountInfo)
	$form1.Controls.Add($btnQuit)
	$form1.Controls.Add($listUsers)
	$form1.Controls.Add($chkForceChange)
	$form1.Controls.Add($lblNewPassword)
	$form1.Controls.Add($txtPassword)
	$form1.Controls.Add($btnReset)
	$form1.Controls.Add($progressBar1)
	$form1.Controls.Add($statusBar1)
	$form1.Controls.Add($label1)
	$form1.ClientSize = '575, 266'
	$form1.FormBorderStyle = 'FixedDialog'
	$form1.Name = "form1"
	$form1.Text = "User Account Management"
	$form1.add_Shown($Populate)
	#
	# label2
	#
	$label2.ForeColor = '128, 128, 255'
	$label2.Location = '382, 182'
	$label2.Name = "label2"
	$label2.Size = '167, 47'
	$label2.TabIndex = 12
	$label2.Text = "Enable or disable an account by selecting a button. The change is immediate."
	$label2.Visible = $False
	#
	# radioDisabled
	#
	$radioDisabled.Location = '299, 201'
	$radioDisabled.Name = "radioDisabled"
	$radioDisabled.Size = '77, 24'
	$radioDisabled.TabIndex = 11
	$radioDisabled.Text = "Disabled"
	$radioDisabled.UseVisualStyleBackColor = $True
	$radioDisabled.Visible = $False
	$radioDisabled.add_Click($ChangeAccount)
	$radioDisabled.add_MouseEnter($ShowTip)
	$radioDisabled.add_MouseLeave($HideTip)
	#
	# radioEnabled
	#
	$radioEnabled.Checked = $True
	$radioEnabled.Location = '299, 178'
	$radioEnabled.Name = "radioEnabled"
	$radioEnabled.Size = '77, 24'
	$radioEnabled.TabIndex = 10
	$radioEnabled.TabStop = $True
	$radioEnabled.Text = "Enabled"
	$radioEnabled.UseVisualStyleBackColor = $True
	$radioEnabled.Visible = $False
	$radioEnabled.add_Click($ChangeAccount)
	$radioEnabled.add_MouseEnter($ShowTip)
	$radioEnabled.add_MouseLeave($HideTip)
	#
	# rtbAccountInfo
	#
	$rtbAccountInfo.BackColor = 'Control'
	$rtbAccountInfo.BorderStyle = 'None'
	$rtbAccountInfo.Font = "Lucida Console, 8.25pt"
	$rtbAccountInfo.Location = '204, 29'
	$rtbAccountInfo.Name = "rtbAccountInfo"
	$rtbAccountInfo.ReadOnly = $True
	$rtbAccountInfo.Size = '359, 142'
	$rtbAccountInfo.TabIndex = 9
	$rtbAccountInfo.Text = ""
	$rtbAccountInfo.Visible = $False
	#
	# btnQuit
	#
	$btnQuit.Location = '104, 203'
	$btnQuit.Name = "btnQuit"
	$btnQuit.Size = '75, 23'
	$btnQuit.TabIndex = 8
	$btnQuit.Text = "Quit"
	$btnQuit.UseVisualStyleBackColor = $True
	$btnQuit.Visible = $False
	$btnQuit.add_Click($Close)
	#
	# listUsers
	#
	$listUsers.FormattingEnabled = $True
	$listUsers.Location = '13, 29'
	$listUsers.Name = "listUsers"
	$listUsers.Size = '166, 121'
	$listUsers.Sorted = $True
	$listUsers.TabIndex = 7
	$listUsers.Visible = $False
	$listUsers.add_SelectedIndexChanged($GetUser)
	#
	# chkForceChange
	#
	$chkForceChange.Checked = $True
	$chkForceChange.CheckState = 'Checked'
	$chkForceChange.Location = '188, 177'
	$chkForceChange.Name = "chkForceChange"
	$chkForceChange.Size = '104, 24'
	$chkForceChange.TabIndex = 6
	$chkForceChange.Text = "Force Change"
	$chkForceChange.UseVisualStyleBackColor = $True
	$chkForceChange.Visible = $False
	#
	# lblNewPassword
	#
	$lblNewPassword.Location = '13, 148'
	$lblNewPassword.Name = "lblNewPassword"
	$lblNewPassword.Size = '100, 23'
	$lblNewPassword.TabIndex = 5
	$lblNewPassword.Text = "New Password"
	$lblNewPassword.TextAlign = 'BottomLeft'
	$lblNewPassword.Visible = $False
	#
	# txtPassword
	#
	$txtPassword.Location = '13, 177'
	$txtPassword.Name = "txtPassword"
	$txtPassword.PasswordChar = '*'
	$txtPassword.Size = '156, 20'
	$txtPassword.TabIndex = 4
	$txtPassword.Visible = $False
	#
	# btnReset
	#
	$btnReset.Location = '13, 203'
	$btnReset.Name = "btnReset"
	$btnReset.Size = '75, 23'
	$btnReset.TabIndex = 3
	$btnReset.Text = "Reset Password"
	$btnReset.UseVisualStyleBackColor = $True
	$btnReset.Visible = $False
	$btnReset.add_Click($ResetPassword)
	#
	# progressBar1
	#
	$progressBar1.Location = '104, 244'
	$progressBar1.Name = "progressBar1"
	$progressBar1.Size = '431, 23'
	$progressBar1.Style = 'Continuous'
	$progressBar1.TabIndex = 2
	#
	# statusBar1
	#
	$statusBar1.Location = '0, 244'
	$statusBar1.Name = "statusBar1"
	$statusBar1.Size = '575, 22'
	$statusBar1.TabIndex = 1
	$statusBar1.Text = "Ready"
	#
	# label1
	#
	$label1.Location = '13, 13'
	$label1.Name = "label1"
	$label1.Size = '100, 23'
	$label1.TabIndex = 0
	$label1.Text = "Select a user"
	$label1.Visible = $False
	$form1.ResumeLayout()
	#endregion Generated Form Code

	#----------------------------------------------

	#Save the initial state of the form
	$InitialFormWindowState = $form1.WindowState
	#Init the OnLoad event to correct the initial state of the form
	$form1.add_Load($Form_StateCorrection_Load)
	#Clean up the control events
	$form1.add_FormClosed($Form_Cleanup_FormClosed)
	#Store the control values when form is closing
	$form1.add_Closing($Form_StoreValues_Closing)
	#Show the Form
	return $form1.ShowDialog()
}
#endregion Source: ADUserForm.psf

#region Source: ComputerPrompt.psf
function Call-ComputerPrompt_psf
{
	#----------------------------------------------
	#region Import the Assemblies
	#----------------------------------------------
	[void][reflection.assembly]::Load('mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
	[void][reflection.assembly]::Load('System.Xml, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System.DirectoryServices, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
	[void][reflection.assembly]::Load('System.Core, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System.ServiceProcess, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
	#endregion Import Assemblies

	#----------------------------------------------
	#region Generated Form Objects
	#----------------------------------------------
	[System.Windows.Forms.Application]::EnableVisualStyles()
	$form1 = New-Object 'System.Windows.Forms.Form'
	$textboxResults = New-Object 'System.Windows.Forms.TextBox'
	$chkBIOS = New-Object 'System.Windows.Forms.CheckBox'
	$chkCompSys = New-Object 'System.Windows.Forms.CheckBox'
	$chkOS = New-Object 'System.Windows.Forms.CheckBox'
	$txtComputerName = New-Object 'System.Windows.Forms.TextBox'
	$btnExit = New-Object 'System.Windows.Forms.Button'
	$btnUpdate = New-Object 'System.Windows.Forms.Button'
	$lblPrompt = New-Object 'System.Windows.Forms.Label'
	$InitialFormWindowState = New-Object 'System.Windows.Forms.FormWindowState'
	#endregion Generated Form Objects

	#----------------------------------------------
	# User Generated Script
	#----------------------------------------------
	
	function OnApplicationLoad {
	#TODO: Add custom code to validate application load
	#TODO: Add Snapins here
	
		return $true #return true for success or false for failure
	}
	
	function OnApplicationExit {
	#TODO: Add custom code clean up on application exit
	
	}
	
	$handler_btnExit_Click={
		$form1.Close()
	}
	
	$handler_btnUpdate_Click={
	
		#save the current cursor
		$cursor = $form1.Cursor
		#change to wait cursor
		$form1.Cursor = [System.Windows.Forms.Cursors]::WaitCursor
		
	   # "Gathering system information for {0}" -f $txtComputerName.Text.toUpper()
		$stringBuilder = New-Object System.Text.StringBuilder
		
		$text =  "System Report for {0} {1}" -f $txtComputerName.Text.toUpper(),(Get-Date -Format g)
		$stringBuilder.AppendLine($text)
	 	$stringBuilder.AppendLine("")
		
	    if ($chkOS.Checked)
	    {
	    	$stringBuilder.AppendLine("Operating System")
			$stringBuilder.Append("*" * 50)
			$text = ""
			$text = (Get-WmiObject win32_operatingsystem -computername $txtComputerName.Text) |Out-String
		
			$stringBuilder.AppendLine($text)
	    }
	    
	    if ($chkCompSys.Checked)
	    {
	   		$stringBuilder.AppendLine("Computer System")
	   		$stringBuilder.Append("*" * 50)
			$text = ""
	   		$text =  (Get-WmiObject win32_computersystem -computername $txtComputerName.Text) |Out-String
	
			$stringBuilder.AppendLine($text)
	    }
	        
	    if ($chkBIOS.Checked)
	    {
	    	$stringBuilder.AppendLine("BIOS")
			$stringBuilder.Append("*" * 50)
			$text = ""
		 	$text = (Get-WmiObject win32_BIOS -computername $txtComputerName.Text) | Out-String
			
		 	$stringBuilder.AppendLine($text)
	    }
	   
	   #write data to the pipeline 
		$textboxResults.Text = $stringBuilder.ToString()
		
		#restore the cursor
		$form1.Cursor = $cursor
		
	}
	
	
		# --End User Generated Script--
	#----------------------------------------------
	#region Generated Events
	#----------------------------------------------
	
	$Form_StateCorrection_Load=
	{
		#Correct the initial state of the form to prevent the .Net maximized form issue
		$form1.WindowState = $InitialFormWindowState
	}
	
	$Form_StoreValues_Closing=
	{
		#Store the control values
		$script:ComputerPrompt_textboxResults = $textboxResults.Text
		$script:ComputerPrompt_chkBIOS = $chkBIOS.Checked
		$script:ComputerPrompt_chkCompSys = $chkCompSys.Checked
		$script:ComputerPrompt_chkOS = $chkOS.Checked
		$script:ComputerPrompt_txtComputerName = $txtComputerName.Text
	}

	
	$Form_Cleanup_FormClosed=
	{
		#Remove all event handlers from the controls
		try
		{
			$btnExit.remove_Click($handler_btnExit_Click)
			$btnUpdate.remove_Click($handler_btnUpdate_Click)
			$form1.remove_Load($Form_StateCorrection_Load)
			$form1.remove_Closing($Form_StoreValues_Closing)
			$form1.remove_FormClosed($Form_Cleanup_FormClosed)
		}
		catch [Exception]
		{ }
	}
	#endregion Generated Events

	#----------------------------------------------
	#region Generated Form Code
	#----------------------------------------------
	$form1.SuspendLayout()
	#
	# form1
	#
	$form1.Controls.Add($textboxResults)
	$form1.Controls.Add($chkBIOS)
	$form1.Controls.Add($chkCompSys)
	$form1.Controls.Add($chkOS)
	$form1.Controls.Add($txtComputerName)
	$form1.Controls.Add($btnExit)
	$form1.Controls.Add($btnUpdate)
	$form1.Controls.Add($lblPrompt)
	$form1.ClientSize = '476, 375'
	$form1.Name = "form1"
	$form1.Text = "Computer Prompt"
	#
	# textboxResults
	#
	$textboxResults.Anchor = 'Top, Bottom, Left, Right'
	$textboxResults.BackColor = 'Window'
	$textboxResults.Location = '13, 56'
	$textboxResults.Multiline = $True
	$textboxResults.Name = "textboxResults"
	$textboxResults.ReadOnly = $True
	$textboxResults.ScrollBars = 'Both'
	$textboxResults.Size = '451, 278'
	$textboxResults.TabIndex = 7
	#
	# chkBIOS
	#
	$chkBIOS.AutoSize = $True
	$chkBIOS.Location = '246, 32'
	$chkBIOS.Name = "chkBIOS"
	$chkBIOS.Size = '51, 17'
	$chkBIOS.TabIndex = 6
	$chkBIOS.Text = "BIOS"
	$chkBIOS.UseVisualStyleBackColor = $True
	#
	# chkCompSys
	#
	$chkCompSys.AutoSize = $True
	$chkCompSys.Location = '132, 32'
	$chkCompSys.Name = "chkCompSys"
	$chkCompSys.Size = '108, 17'
	$chkCompSys.TabIndex = 5
	$chkCompSys.Text = "Computer System"
	$chkCompSys.UseVisualStyleBackColor = $True
	#
	# chkOS
	#
	$chkOS.AutoSize = $True
	$chkOS.Checked = $True
	$chkOS.CheckState = 'Checked'
	$chkOS.Location = '13, 32'
	$chkOS.Name = "chkOS"
	$chkOS.Size = '109, 17'
	$chkOS.TabIndex = 4
	$chkOS.Text = "Operating System"
	$chkOS.UseVisualStyleBackColor = $True
	#
	# txtComputerName
	#
	$txtComputerName.Location = '138, 6'
	$txtComputerName.Name = "txtComputerName"
	$txtComputerName.Size = '180, 20'
	$txtComputerName.TabIndex = 3
	$txtComputerName.Text = "$env:computername"
	#
	# btnExit
	#
	$btnExit.Anchor = 'Bottom, Right'
	$btnExit.Location = '389, 340'
	$btnExit.Name = "btnExit"
	$btnExit.Size = '75, 23'
	$btnExit.TabIndex = 2
	$btnExit.Text = "Exit"
	$btnExit.UseVisualStyleBackColor = $True
	$btnExit.add_Click($handler_btnExit_Click)
	#
	# btnUpdate
	#
	$btnUpdate.Anchor = 'Bottom, Left'
	$btnUpdate.Location = '13, 340'
	$btnUpdate.Name = "btnUpdate"
	$btnUpdate.Size = '75, 23'
	$btnUpdate.TabIndex = 1
	$btnUpdate.Text = "Update"
	$btnUpdate.UseVisualStyleBackColor = $True
	$btnUpdate.add_Click($handler_btnUpdate_Click)
	#
	# lblPrompt
	#
	$lblPrompt.AutoSize = $True
	$lblPrompt.Location = '12, 9'
	$lblPrompt.Name = "lblPrompt"
	$lblPrompt.Size = '120, 13'
	$lblPrompt.TabIndex = 0
	$lblPrompt.Text = "Enter a computer name:"
	$form1.ResumeLayout()
	#endregion Generated Form Code

	#----------------------------------------------

	#Save the initial state of the form
	$InitialFormWindowState = $form1.WindowState
	#Init the OnLoad event to correct the initial state of the form
	$form1.add_Load($Form_StateCorrection_Load)
	#Clean up the control events
	$form1.add_FormClosed($Form_Cleanup_FormClosed)
	#Store the control values when form is closing
	$form1.add_Closing($Form_StoreValues_Closing)
	#Show the Form
	return $form1.ShowDialog()
}
#endregion Source: ComputerPrompt.psf

#region Source: SystemInformation.psf
function Call-SystemInformation_psf
{
	#----------------------------------------------
	#region Import the Assemblies
	#----------------------------------------------
	[void][reflection.assembly]::Load('mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
	[void][reflection.assembly]::Load('System.Xml, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System.DirectoryServices, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
	[void][reflection.assembly]::Load('System.Core, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System.ServiceProcess, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
	#endregion Import Assemblies

	#----------------------------------------------
	#region Generated Form Objects
	#----------------------------------------------
	[System.Windows.Forms.Application]::EnableVisualStyles()
	$form1 = New-Object 'System.Windows.Forms.Form'
	$btnRefresh = New-Object 'System.Windows.Forms.Button'
	$rtbPerfData = New-Object 'System.Windows.Forms.RichTextBox'
	$pictureBox1 = New-Object 'System.Windows.Forms.PictureBox'
	$lblServicePack = New-Object 'System.Windows.Forms.Label'
	$lblOS = New-Object 'System.Windows.Forms.Label'
	$statusBar1 = New-Object 'System.Windows.Forms.StatusBar'
	$btnClose = New-Object 'System.Windows.Forms.Button'
	$comboServers = New-Object 'System.Windows.Forms.ComboBox'
	$InitialFormWindowState = New-Object 'System.Windows.Forms.FormWindowState'
	#endregion Generated Form Objects

	#----------------------------------------------
	# User Generated Script
	#----------------------------------------------
	
	Function Display-OSPerf {
	#Displays the key OS Performance counters for a host
	#Author Thomas Lee - tfl@psp.co.uk
	
	Param ($computer = "localhost")   #default to local host
	
	#Use WMI to get current performance data, and do conversions as needed
	
	$perf= Get-WmiObject Win32_PerfFormattedData_PerfOS_System -computer $computer #get perf
	$uptime=$perf.SystemUpTime/3600                                      # convert to hours
	
	# Now print the data, using normal .NET formatting
	
	"Performance stats for: {0}" -f $computer.toUpper()
	"{0,30}{1,10}" -f "Processes", $perf.Processes
	"{0,30}{1,10}" -f "Threads", $perf.Threads
	"{0,30}{1,12}" -f "System Up Time `(hours`)", $uptime.tostring("00.0")
	"{0,30}{1,12}" -f "Alignment Fixups/sec", $perf.AlignmentFixupsPersec.tostring("###,##0.0")
	"{0,30}{1,12}" -f "Context Switches/sec", $perf.ContextSwitchesPersec.tostring("###,##0.0")
	"{0,30}{1,12}" -f "Exception Dispatches/sec", $perf.ExceptionDispatchesPersec.tostring("###,##0.0")
	"{0,30}{1,12}" -f "File Control Bytes/sec", $perf.FileControlBytesPersec.tostring("###,##0.0")
	"{0,30}{1,12}" -f "File Control Operations/sec", $perf.FileControlOperationsPersec.tostring("###,##0.0")
	"{0,30}{1,12}" -f "File Data OperationsPersec", $perf.FileDataOperationsPersec.tostring("###,##0.0")
	"{0,30}{1,12}" -f "File Read Bytes/sec", $perf.FileReadBytesPersec.tostring("###,##0.0")
	"{0,30}{1,12}" -f "File Read Operations/sec", $perf.FileReadOperationsPersec.tostring("###,##0.0")
	"{0,30}{1,12}" -f "File Write Bytes/sec", $perf.FileWriteBytesPersec.tostring("###,##0.0")
	"{0,30}{1,12}" -f "File Write Operations/sec", $perf.FileWriteOperationsPersec.tostring("###,##0.0")
	"{0,30}{1,12}" -f "Floating Emulations/rsec", $perf.FloatingEmulationsPersec.tostring("###,##0.0")
	"{0,30}{1,15}" -f "Percent Registry Quota Used", $($perf.PercentRegistryQuotaInUse/100).tostring("P")
	"{0,30}{1,10}" -f "Processor Queue Length", $perf.ProcessorQueueLength
	"{0,30}{1,10}" -f "System Calls Persec", $perf.SystemCallsPersec
	""
	}
	
	
	function OnApplicationLoad {
	#Note: This function runs before the form is created
	#TODO: Add snapins and custom code to validate the application load
		$script:list = Read-Host "Please enter the list file path (Default: c:\computers.txt)"
		
		if($script:list -eq $null -or $script:list.Length -eq 0)
		{
			$script:list = "c:\computers.txt"
		}
		
	if (!(get-item $global:list -ea "silentlycontinue").exists) {
	
		Write-Warning "Failed to find $list"
		#exit the script
			return $false
		}
	
		return $true #return true for success or false for failure
	}
	
	function OnApplicationExit {
	#Note: This function runs after the form is closed
	#TODO: Add custom code to clean up and unload snapins when the application exits
	
	}
	
	$Close={
	    $form1.close()
	
	}
	
	$PopulateList={
	    $statusBar1.text="Getting computer names from $list"
	    Get-Content $list | foreach {
	    $comboServers.items.add($_.Trim())
	
	    $statusBar1.Text="Ready"
	    }
	}
	
	$GetData={
	    $statusBar1.text="Getting Operating System information for {0}" -f $comboServers.SelectedItem.toUpper()
	    #clear values
	    $rtbPerfData.text=$Null
	    $lblOS.text=$Null
	    $lblServicePack.Text=$Null
	    
	    $form1.Refresh()
	    
	    #turn off the error pipeline
	    $errorActionPreference="SilentlyContinue"
	    
	    #remove any existing instances of $os
	    if ($os) {Remove-Variable os}
	    
	    $os=Get-WmiObject win32_operatingsystem -computer $comboServers.SelectedItem -ea "SilentlyContinue"
	    if ($os) {
	    #computer exists and can be contacted
	        $lblOS.forecolor="Black"
	
	        $lblOS.text=$os.Caption
	        $lblServicePack.Text=$os.CSDVersion
	        
	        $statusBar1.text="Getting Operating System Performance Data..please wait"
	        $data=Display-OSPerf $comboServers.SelectedItem | Out-String
	        $rtbPerfData.text=$data.Trim()
	        
	        $lblOS.Visible=$True
	        $lblServicePack.visible=$True
	        $rtbPerfData.Visible=$True
	        $btnRefresh.Enabled=$True
	    }
	    else {
	    #failed to find or connect to specified computer
	    $lblOS.forecolor="RED"
	    $lblOS.text="Failed to find or connect to {0}" -f $comboServers.SelectedItem.toUpper()
	    $lblOS.Visible=$True
	    $lblServicePack.Visible=$false
	    }
	    
	    $errorActionPreference="Continue"
	    $statusBar1.Text="Ready"
	
	}
	
		# --End User Generated Script--
	#----------------------------------------------
	#region Generated Events
	#----------------------------------------------
	
	$Form_StateCorrection_Load=
	{
		#Correct the initial state of the form to prevent the .Net maximized form issue
		$form1.WindowState = $InitialFormWindowState
	}
	
	$Form_StoreValues_Closing=
	{
		#Store the control values
		$script:SystemInformation_rtbPerfData = $rtbPerfData.Text
		$script:SystemInformation_comboServers = $comboServers.Text
		$script:SystemInformation_comboServers_SelectedItem = $comboServers.SelectedItems
	}

	
	$Form_Cleanup_FormClosed=
	{
		#Remove all event handlers from the controls
		try
		{
			$btnRefresh.remove_Click($GetData)
			$btnClose.remove_Click($Close)
			$comboServers.remove_SelectedIndexChanged($GetData)
			$form1.remove_Load($PopulateList)
			$form1.remove_Load($Form_StateCorrection_Load)
			$form1.remove_Closing($Form_StoreValues_Closing)
			$form1.remove_FormClosed($Form_Cleanup_FormClosed)
		}
		catch [Exception]
		{ }
	}
	#endregion Generated Events

	#----------------------------------------------
	#region Generated Form Code
	#----------------------------------------------
	$form1.SuspendLayout()
	#
	# form1
	#
	$form1.Controls.Add($btnRefresh)
	$form1.Controls.Add($rtbPerfData)
	$form1.Controls.Add($pictureBox1)
	$form1.Controls.Add($lblServicePack)
	$form1.Controls.Add($lblOS)
	$form1.Controls.Add($statusBar1)
	$form1.Controls.Add($btnClose)
	$form1.Controls.Add($comboServers)
	$form1.ClientSize = '390, 387'
	$form1.FormBorderStyle = 'FixedToolWindow'
	$form1.Name = "form1"
	$form1.Text = "System Information"
	$form1.add_Load($PopulateList)
	#
	# btnRefresh
	#
	$btnRefresh.Enabled = $False
	$btnRefresh.Location = '77, 328'
	$btnRefresh.Name = "btnRefresh"
	$btnRefresh.Size = '75, 23'
	$btnRefresh.TabIndex = 7
	$btnRefresh.Text = "Refresh"
	$btnRefresh.UseVisualStyleBackColor = $True
	$btnRefresh.add_Click($GetData)
	#
	# rtbPerfData
	#
	$rtbPerfData.BackColor = 'Control'
	$rtbPerfData.BorderStyle = 'None'
	$rtbPerfData.Font = "Lucida Console, 8.25pt"
	$rtbPerfData.Location = '13, 86'
	$rtbPerfData.Name = "rtbPerfData"
	$rtbPerfData.Size = '365, 223'
	$rtbPerfData.TabIndex = 6
	$rtbPerfData.Text = ""
	#
	# pictureBox1
	#
	$pictureBox1.BorderStyle = 'Fixed3D'
	$pictureBox1.ImageLocation = "http://www.sapien.com/_images/header_sapien.gif"
	$pictureBox1.Location = '297, 3'
	$pictureBox1.Name = "pictureBox1"
	$pictureBox1.Size = '66, 67'
	$pictureBox1.TabIndex = 1
	$pictureBox1.TabStop = $False
	#
	# lblServicePack
	#
	$lblServicePack.Font = "Lucida Console, 8.25pt, style=Bold"
	$lblServicePack.Location = '13, 60'
	$lblServicePack.Name = "lblServicePack"
	$lblServicePack.Size = '278, 23'
	$lblServicePack.TabIndex = 0
	$lblServicePack.Text = "ServicePack"
	$lblServicePack.Visible = $False
	#
	# lblOS
	#
	$lblOS.Font = "Lucida Console, 8.25pt, style=Bold"
	$lblOS.Location = '12, 37'
	$lblOS.Name = "lblOS"
	$lblOS.Size = '278, 23'
	$lblOS.TabIndex = 2
	$lblOS.Text = "operating system information"
	$lblOS.Visible = $False
	#
	# statusBar1
	#
	$statusBar1.Location = '0, 365'
	$statusBar1.Name = "statusBar1"
	$statusBar1.Size = '390, 22'
	$statusBar1.TabIndex = 5
	$statusBar1.Text = "statusBar1"
	#
	# btnClose
	#
	$btnClose.Location = '245, 328'
	$btnClose.Name = "btnClose"
	$btnClose.Size = '75, 23'
	$btnClose.TabIndex = 3
	$btnClose.Text = "Close"
	$btnClose.UseVisualStyleBackColor = $True
	$btnClose.add_Click($Close)
	#
	# comboServers
	#
	$comboServers.FormattingEnabled = $True
	$comboServers.Location = '13, 13'
	$comboServers.Name = "comboServers"
	$comboServers.Size = '176, 21'
	$comboServers.TabIndex = 0
	$comboServers.Text = "Select a server from the list"
	$comboServers.add_SelectedIndexChanged($GetData)
	$form1.ResumeLayout()
	#endregion Generated Form Code

	#----------------------------------------------

	#Save the initial state of the form
	$InitialFormWindowState = $form1.WindowState
	#Init the OnLoad event to correct the initial state of the form
	$form1.add_Load($Form_StateCorrection_Load)
	#Clean up the control events
	$form1.add_FormClosed($Form_Cleanup_FormClosed)
	#Store the control values when form is closing
	$form1.add_Closing($Form_StoreValues_Closing)
	#Show the Form
	return $form1.ShowDialog()
}
#endregion Source: SystemInformation.psf

#region Source: TopProcesses.psf
function Call-TopProcesses_psf
{
	#----------------------------------------------
	#region Import the Assemblies
	#----------------------------------------------
	[void][reflection.assembly]::Load('mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
	[void][reflection.assembly]::Load('System.Xml, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System.DirectoryServices, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
	[void][reflection.assembly]::Load('System.Core, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System.ServiceProcess, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
	#endregion Import Assemblies

	#----------------------------------------------
	#region Generated Form Objects
	#----------------------------------------------
	[System.Windows.Forms.Application]::EnableVisualStyles()
	$form1 = New-Object 'System.Windows.Forms.Form'
	$button1 = New-Object 'System.Windows.Forms.Button'
	$richTextBox1 = New-Object 'System.Windows.Forms.RichTextBox'
	$label1 = New-Object 'System.Windows.Forms.Label'
	$InitialFormWindowState = New-Object 'System.Windows.Forms.FormWindowState'
	#endregion Generated Form Objects

	#----------------------------------------------
	# User Generated Script
	#----------------------------------------------
	function OnApplicationLoad {
	#Note: This function runs before the form is created
	#TODO: Add snapins and custom code to validate the application load
	
		return $true #return true for success or false for failure
	}
	
	function OnApplicationExit {
	#Note: This function runs after the form is closed
	#TODO: Add custom code to clean up and unload snapins when the application exits
	
	}
	
	$Close={
	$form1.Close()
	}
	
	$BuildReport={
	
	$computername = Read-Host -Prompt "Please enter the computer name (Default: $env:computername)"
	
	if(($computername -eq $null) -or ($computername.Length -eq 0))
	{
		$computername = $env:computername
	}
	#use WMI to get processes, excluding the System Idle Process
	$processes=Get-WmiObject Win32_process -computername $computername -filter "Name != 'System Idle Process'"
	
	#Sort by WorkingSet size in descending order and select the first 10
	#These object are then piped to format-table to create a custom table
	#which is turned into a string at the end
	$data = $processes | sort WorkingSetSize -Descending | select -first 10 | 
	Format-Table @{label="ID";Expression={$_.Handle}},Name,@{label="WS(MB)";Expression={("{0:N2}" -f ($_.WorkingSetSize/1MB))}} -autosize | Out-String
	
	#populate the RightTextBox control with $data
	$richTextBox1.text=$data.Trim()
	$form1.Text = $computername.ToUpper()
	}
	
		# --End User Generated Script--
	#----------------------------------------------
	#region Generated Events
	#----------------------------------------------
	
	$Form_StateCorrection_Load=
	{
		#Correct the initial state of the form to prevent the .Net maximized form issue
		$form1.WindowState = $InitialFormWindowState
	}
	
	$Form_StoreValues_Closing=
	{
		#Store the control values
		$script:TopProcesses_richTextBox1 = $richTextBox1.Text
	}

	
	$Form_Cleanup_FormClosed=
	{
		#Remove all event handlers from the controls
		try
		{
			$button1.remove_Click($Close)
			$form1.remove_Load($BuildReport)
			$form1.remove_Load($Form_StateCorrection_Load)
			$form1.remove_Closing($Form_StoreValues_Closing)
			$form1.remove_FormClosed($Form_Cleanup_FormClosed)
		}
		catch [Exception]
		{ }
	}
	#endregion Generated Events

	#----------------------------------------------
	#region Generated Form Code
	#----------------------------------------------
	$form1.SuspendLayout()
	#
	# form1
	#
	$form1.Controls.Add($button1)
	$form1.Controls.Add($richTextBox1)
	$form1.Controls.Add($label1)
	$form1.ClientSize = '284, 264'
	$form1.FormBorderStyle = 'FixedToolWindow'
	$form1.Name = "form1"
	$form1.Text = "$computername.ToUpper()"
	$form1.add_Load($BuildReport)
	#
	# button1
	#
	$button1.Location = '109, 229'
	$button1.Name = "button1"
	$button1.Size = '75, 23'
	$button1.TabIndex = 2
	$button1.Text = "Close"
	$button1.UseVisualStyleBackColor = $True
	$button1.add_Click($Close)
	#
	# richTextBox1
	#
	$richTextBox1.BackColor = 'Window'
	$richTextBox1.Font = "Lucida Console, 8.25pt"
	$richTextBox1.Location = '12, 27'
	$richTextBox1.Name = "richTextBox1"
	$richTextBox1.ReadOnly = $True
	$richTextBox1.Size = '260, 186'
	$richTextBox1.TabIndex = 1
	$richTextBox1.Text = "data"
	#
	# label1
	#
	$label1.Location = '12, 9'
	$label1.Name = "label1"
	$label1.Size = '100, 23'
	$label1.TabIndex = 0
	$label1.Text = "Top 10 Processes"
	$form1.ResumeLayout()
	#endregion Generated Form Code

	#----------------------------------------------

	#Save the initial state of the form
	$InitialFormWindowState = $form1.WindowState
	#Init the OnLoad event to correct the initial state of the form
	$form1.add_Load($Form_StateCorrection_Load)
	#Clean up the control events
	$form1.add_FormClosed($Form_Cleanup_FormClosed)
	#Store the control values when form is closing
	$form1.add_Closing($Form_StoreValues_Closing)
	#Show the Form
	return $form1.ShowDialog()
}
#endregion Source: TopProcesses.psf

#region Source: Globals.ps1
	#--------------------------------------------
	# Declare Global Variables and Functions here
	#--------------------------------------------
	
	[string]$SampleGlobalVariable = "Sample Variable"
	
	#--------------------------------------------
	# Packager Command Line Parsing Functions
	#--------------------------------------------
	
	function Parse-Commandline
	{
		Param([string]$CommandLine)
		
		$Arguments = New-Object System.Collections.Specialized.StringCollection
		#Find First Quote
		$index = $CommandLine.IndexOf('"')
	
		while ( $index -ne -1)
		{#Continue as along as we find a quote
		
			#Find Closing Quote
			$closeIndex = $CommandLine.IndexOf('"',$index + 1)
			
			if($closeIndex -eq -1)
			{ 
				break #Can't find a match
			}
			
			$value = $CommandLine.Substring($index + 1,$closeIndex - ($index + 1))
			
			[void]$Arguments.Add($value)
			$index = $closeIndex
	
			#Find First Quote
			$index = $CommandLine.IndexOf('"',$index + 1)
		}
		
		return $Arguments
	}
	
	function Convert-ArgumentsToDictionary
	{
		Param([System.Collections.Specialized.StringCollection] $Params, [char] $ParamIndicator)
		
		$Dictionary = New-Object System.Collections.Specialized.StringDictionary
		
		for($index = 0; $index -lt $Params.Count; $index++)
		{
			[string]$param = $Params[$index]
			
			#Clear the values
			$key = ""
			$value = ""
	
			if($param.StartsWith($ParamIndicator))
			{
				#Remove the indicator
				$key = $param.Remove(0,1)
				
				if($index  + 1 -lt $Params.Count)
				{
					#Check if the next Argument is a parameter
					[string]$param = $Params[$index + 1]
					if($param.StartsWith($ParamIndicator) -ne $true )
					{
						#If it isn't a parameter then set it as the value
						$value = $param
						$index++
					}
				}
				
				$Dictionary[$key] = $value
			}#else skip
		}
			
		return $Dictionary
	}
	
	#endregion Source: Globals.ps1

#Start the application
Main ($CommandLine)
